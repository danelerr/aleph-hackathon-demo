{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-93cedb8cb31655a493763259bb46925cd77a6997",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/Vigia.sol": "project/contracts/Vigia.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Vigia.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title Vigia\r\n * @dev Smart contract para reportar y validar incidencias urbanas\r\n * @author Aleph Hackathon Team\r\n */\r\ncontract Vigia {\r\n    struct Report {\r\n        uint256 id;\r\n        address creator;\r\n        string latitude;\r\n        string longitude;\r\n        string imageHash; // CID de IPFS\r\n        string description;\r\n        uint256 timestamp;\r\n        string status; // \"Sin verificar\" o \"Verificado\"\r\n        address[] confirmations;\r\n        string category; // Categoría del reporte (bache, semáforo, etc.)\r\n    }\r\n\r\n    uint256 private _reportCounter;\r\n    mapping(uint256 => Report) public reports;\r\n    mapping(uint256 => mapping(address => bool)) public hasConfirmed;\r\n\r\n    // Configuración de validación\r\n    uint256 public constant CONFIRMATION_THRESHOLD = 3;\r\n    \r\n    // Eventos\r\n    event ReporteCreado(\r\n        uint256 indexed id,\r\n        address indexed creator,\r\n        string imageHash,\r\n        string category,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event ReporteValidado(\r\n        uint256 indexed id,\r\n        address indexed validator,\r\n        string newStatus,\r\n        uint256 confirmaciones\r\n    );\r\n\r\n    // Modificadores\r\n    modifier reportExists(uint256 _reportId) {\r\n        require(reports[_reportId].id != 0, \"El reporte no existe\");\r\n        _;\r\n    }\r\n\r\n    modifier notReportCreator(uint256 _reportId) {\r\n        require(reports[_reportId].creator != msg.sender, \"No puedes validar tu propio reporte\");\r\n        _;\r\n    }\r\n\r\n    modifier notAlreadyConfirmed(uint256 _reportId) {\r\n        require(!hasConfirmed[_reportId][msg.sender], \"Ya has validado este reporte\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Crear un nuevo reporte de incidencia\r\n     * @param _latitude Latitud de la ubicación\r\n     * @param _longitude Longitud de la ubicación  \r\n     * @param _imageHash Hash IPFS de la imagen\r\n     * @param _description Descripción del problema\r\n     * @param _category Categoría del reporte\r\n     */\r\n    function reportarIncidencia(\r\n        string memory _latitude,\r\n        string memory _longitude,\r\n        string memory _imageHash,\r\n        string memory _description,\r\n        string memory _category\r\n    ) public {\r\n        require(bytes(_latitude).length > 0, \"Latitud requerida\");\r\n        require(bytes(_longitude).length > 0, \"Longitud requerida\");\r\n        require(bytes(_description).length > 0, \"Descripcion requerida\");\r\n        require(bytes(_category).length > 0, \"Categoria requerida\");\r\n\r\n        _reportCounter++;\r\n        uint256 newReportId = _reportCounter;\r\n\r\n        reports[newReportId] = Report({\r\n            id: newReportId,\r\n            creator: msg.sender,\r\n            latitude: _latitude,\r\n            longitude: _longitude,\r\n            imageHash: _imageHash,\r\n            description: _description,\r\n            timestamp: block.timestamp,\r\n            status: \"Sin verificar\",\r\n            confirmations: new address[](0),\r\n            category: _category\r\n        });\r\n\r\n        emit ReporteCreado(newReportId, msg.sender, _imageHash, _category, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Validar un reporte existente\r\n     * @param _reportId ID del reporte a validar\r\n     */\r\n    function validarReporte(uint256 _reportId) \r\n        public \r\n        reportExists(_reportId)\r\n        notReportCreator(_reportId)\r\n        notAlreadyConfirmed(_reportId)\r\n    {\r\n        Report storage reportToValidate = reports[_reportId];\r\n        \r\n        reportToValidate.confirmations.push(msg.sender);\r\n        hasConfirmed[_reportId][msg.sender] = true;\r\n\r\n        if (reportToValidate.confirmations.length >= CONFIRMATION_THRESHOLD) {\r\n            reportToValidate.status = \"Verificado\";\r\n        }\r\n\r\n        emit ReporteValidado(\r\n            _reportId, \r\n            msg.sender, \r\n            reportToValidate.status, \r\n            reportToValidate.confirmations.length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Obtener todos los reportes\r\n     * @return Array con todos los reportes\r\n     */\r\n    function getAllReports() public view returns (Report[] memory) {\r\n        Report[] memory allReports = new Report[](_reportCounter);\r\n        for (uint i = 0; i < _reportCounter; i++) {\r\n            allReports[i] = reports[i + 1];\r\n        }\r\n        return allReports;\r\n    }\r\n\r\n    /**\r\n     * @dev Obtener un reporte específico por ID\r\n     * @param _reportId ID del reporte\r\n     * @return El reporte solicitado\r\n     */\r\n    function getReport(uint256 _reportId) \r\n        public \r\n        view \r\n        reportExists(_reportId) \r\n        returns (Report memory) \r\n    {\r\n        return reports[_reportId];\r\n    }\r\n\r\n    /**\r\n     * @dev Obtener reportes por categoría\r\n     * @param _category Categoría a filtrar\r\n     * @return Array de reportes de la categoría especificada\r\n     */\r\n    function getReportsByCategory(string memory _category) \r\n        public \r\n        view \r\n        returns (Report[] memory) \r\n    {\r\n        uint256 count = 0;\r\n        \r\n        // Contar reportes de la categoría\r\n        for (uint i = 1; i <= _reportCounter; i++) {\r\n            if (keccak256(bytes(reports[i].category)) == keccak256(bytes(_category))) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Crear array del tamaño correcto\r\n        Report[] memory categoryReports = new Report[](count);\r\n        uint256 index = 0;\r\n\r\n        // Llenar el array\r\n        for (uint i = 1; i <= _reportCounter; i++) {\r\n            if (keccak256(bytes(reports[i].category)) == keccak256(bytes(_category))) {\r\n                categoryReports[index] = reports[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return categoryReports;\r\n    }\r\n\r\n    /**\r\n     * @dev Obtener reportes por creador\r\n     * @param _creator Dirección del creador\r\n     * @return Array de reportes del creador especificado\r\n     */\r\n    function getReportsByCreator(address _creator) \r\n        public \r\n        view \r\n        returns (Report[] memory) \r\n    {\r\n        uint256 count = 0;\r\n        \r\n        // Contar reportes del creador\r\n        for (uint i = 1; i <= _reportCounter; i++) {\r\n            if (reports[i].creator == _creator) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Crear array del tamaño correcto\r\n        Report[] memory creatorReports = new Report[](count);\r\n        uint256 index = 0;\r\n\r\n        // Llenar el array\r\n        for (uint i = 1; i <= _reportCounter; i++) {\r\n            if (reports[i].creator == _creator) {\r\n                creatorReports[index] = reports[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return creatorReports;\r\n    }\r\n\r\n    /**\r\n     * @dev Obtener el número total de reportes\r\n     * @return Número total de reportes\r\n     */\r\n    function getTotalReports() public view returns (uint256) {\r\n        return _reportCounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Verificar si un usuario ya confirmó un reporte\r\n     * @param _reportId ID del reporte\r\n     * @param _user Dirección del usuario\r\n     * @return true si ya confirmó, false si no\r\n     */\r\n    function hasUserConfirmed(uint256 _reportId, address _user) \r\n        public \r\n        view \r\n        returns (bool) \r\n    {\r\n        return hasConfirmed[_reportId][_user];\r\n    }\r\n}\r\n"
      }
    }
  }
}